CREATE OR REPLACE FUNCTION order_plan(id_task integer)
-- функция добавляет строки в таблицу ПЛАН_МАРШРУТ
AS $BODY$

    DECLARE
        id_ingredient integer;      -- ИД_ИГРЕДИЕНТА
        mass float;                 -- масса ингредиента
        id_akv integer;             --
        finish boolean;             --
        end_date date;              -- дата завершения пути и сбора
        having_mass float;          -- масса ингредиента, которая уже есть
        end_persent float;          --

    BEGIN
        -- узнать, какие ингредиенты нужны

        -- узнать, какие существа их содержат
        -- узнать, ближайшие популяции с ними

        for id_ingredient in select
        for id_ingredient, mass in select СОСТАВ join ЗАКАЗ using(ИД_ЛЕКАРСТВА) where (ИД_ЗАКАЗА = id_task)


    END;

$BODY$ LANGUAGE plpgsql;




with recursive NeperNum as (
    select
        20 as n,
        20 + 20 / (20 + 1.0) as temp
    union
    select
        n - 1 as n,
        n + n / temp as temp
    from NeperNum
    where n > 0
)
select (2.0 + 1.0 / temp) as e from NeperNum where n = 0;


CREATE OR REPLACE FUNCTION getLocation(id_ingredient integer, amount integer)
RETURNS integer
AS $BODY$
    DECLARE
        value integer;
        locationID integer;
        ship_x float;
        ship_y float;
    BEGIN
        select ШИРОТА into ship_x from КОРАБЛЬ;
        select ДОЛГОТА into ship_y from КОРАБЛЬ;

        select ИД_ЛОКАЦИИ into value from (
            values  (1, 2, 25),
                    (1, 3, 12),
                    (2, 3, 56))
            as t (ИД_АКВ_1, ИД_АКВ_2, ДИСТ) join where distance = 56;

        return value;
    END;

$BODY$ LANGUAGE plpgsql;


/* temp inserts
        insert into ЛЕКАРСТВО
        values  (1, 'medicine1', null, false, 100);

        insert into СОСТАВ
        values  (1, 1, 1.2),
                (1, 2, 1.5);

        insert into ЛОКАЦИЯ
        values  (1, 1, 1, 100, 23.2, -1),
                (2, 1, 1, 260, 30.2, -15),
                (3, 2, 2, 1000, 102, 12);

        insert into ИНГРЕДИЕНТ
        values  (1, 'ЖАБА', 'ФУ', 1, 100500, null),
                (2, 'БЕЕЕ что', 'ФУБЕ', 1, 100, 'УУУ'),
                (3, 'ЖИВОТ', 'РАМА', 2, 200, 'хех');

        insert into СПРАВОЧНИК_СУЩЕСТВ
        values  (1, true),
                (2, false);

        insert into ЖИВОЕ_СУЩЕСТВО
        values  (1, 'class1', 'sel1', 'vid1', null),
                (2, 'class2', 'sem2', 'vid2', null),
                (3, 'class3', 'sem3', 'vid3', null);

        insert into МИНЕРАЛЬНОЕ_ВЕЩЕСТВО
        values  (1, 'min4', 'type1'),
                (2, 'min5', 'type5'),
                (3, 'min6', 'type6');

        insert into АКВАТОРИЯ
        values  (1, 'залив', 'Аденский залив', 12.73, 47.59, 'является частью Аравийского моря Индийского океана'),
                (2, 'залив', 'Бенгальский залив', 14.04, 87.53, 'морской залив, расположенный в северо-восточной части Индийского океана'),
                (3, 'залив', 'Большой Австралийский залив', -36.73, 131.63, 'крупный открытый залив, относящийся к водам Индийского океана');

*/

        select ЛОКАЦИЯ.ИД_ЛОКАЦИИ, ЛОКАЦИЯ.ИД_СУЩЕСТВА, ЛОКАЦИЯ.КОЛИЧЕСТВО from ЛОКАЦИЯ join ИНГРЕДИЕНТ using(ИД_СУЩЕСТВА) join СОСТАВ using(ИД_ИНГРЕДИЕНТА) join ЛЕКАРСТВО using(ИД_ЛЕКАРСТВА);

        IF (NEW.НОМЕР_В_ОЧЕРЕДИ <> 1) THEN RETURN NEW;
        END IF;
        FOR id_ingr, mass IN SELECT ИД_ИНГРЕДИЕНТА, МАССА FROM СОСТАВ WHERE ИД_ЛЕКАРСТВА = NEW.ИД_ЛЕКАРСТВА
        LOOP
        SELECT ИД_АКВАТОРИИ  INTO id_akv  FROM ИНГРЕДИЕНТ WHERE ИД_ИНГРЕДИЕНТА = id_ingr;
            FOR having_mass IN SELECT МАССА  FROM НАЛИЧИЕ_ИНГРЕДИЕНТОВ WHERE (ИД_ИНГРЕДИЕНТА = id_ingr) AND (ГОДЕН_ДО > NOW())
            LOOP
            mass := mass - having_mass;
            END LOOP;

        -- тут надо придумать что-то поумнее

        IF (mass > 0) THEN
            finish := FALSE;
            end_date := NOW() + ROUND(mass/10);
            ELSE finish := TRUE; end_date := NOW();
        END IF;
        INSERT INTO ПЛАН_МАРШРУТ VALUES (NEW.ИД_ЗАКАЗА, id_ingr, id_akv, end_date, finish);
        END LOOP;

            end_persent := (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА) AND (СОБРАНО = TRUE)) /
            (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА));
            SELECT MAX(ДАТА_ЗАВЕРШЕНИЯ)  INTO end_date  FROM ПЛАН_МАРШРУТ WHERE ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА;

            INSERT INTO "СТАТУС_ЗАКАЗА" VALUES (NEW.ИД_ЗАКАЗА, end_persent, end_date);

            RETURN NEW;


CREATE TRIGGER planning
AFTER  INSERT ON "ЗАКАЗ"
FOR EACH ROW
EXECUTE PROCEDURE order_plan();


CREATE OR REPLACE FUNCTION update_plan() RETURNS trigger
AS $$
DECLARE
id_ingr integer[];
mass float[];
id_order integer;
end_persent float;
end_date date;
op varchar(3);
BEGIN
IF (TG_OP = 'INSERT') THEN
	 op = 'NEW';
ELSIF (TG_OP = 'DELETE') THEN
	 op = 'OLD';
END IF;

	EXECUTE 'UPDATE ПЛАН_МАРШРУТ SET ДАТА_ЗАВЕРШЕНИЯ  = ДАТА_ЗАВЕРШЕНИЯ - ROUND(' || op || ' .МАССА/10) WHERE ИД_ИНГРЕДИЕНТА == '|| op || '.ИД_ИНГРЕДИЕНТА';

	FOR id_order IN EXECUTE 'SELECT ИД_ЗАКАЗА  FROM ПЛАН_МАРШРУТ WHERE ИД_ИНГРЕДИЕНТА == ' || op || '.ИД_ИНГРЕДИЕНТА'
	LOOP
	end_persent := (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = id_order) AND (СОБРАНО = TRUE)) /
	(SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = id_order));
	SELECT MAX(ДАТА_ЗАВЕРШЕНИЯ)  INTO end_date  FROM ПЛАН_МАРШРУТ WHERE ИД_ЗАКАЗА = id_order;

	UPDATE СТАТУС_ЗАКАЗА SET ВЫПОЛНЕНИЕ = end_persent, ДАТА_ЗАВЕРШЕНИЯ = end_date WHERE ИД_ЗАКАЗА = id_order;
	END LOOP;
	EXECUTE 'RETURN ' || op;

END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER planning
AFTER  INSERT OR DELETE ON "НАЛИЧИЕ_ИНГРЕДИЕНТОВ"
FOR EACH ROW
EXECUTE PROCEDURE update_plan();

CREATE OR REPLACE FUNCTION update_orders() RETURNS trigger
AS $$
DECLARE
val integer;
BEGIN
SELECT MAX(НОМЕР_В_ОЧЕРЕДИ) INTO val FROM ЗАКАЗ;
IF val IS NOT NULL  THEN
NEW.НОМЕР_В_ОЧЕРЕДИ = val + 1;
ELSIF TRUE THEN NEW.НОМЕР_В_ОЧЕРЕДИ = 1;
END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER orders
BEFORE INSERT ON "ЗАКАЗ"
FOR EACH ROW
EXECUTE PROCEDURE update_orders();
