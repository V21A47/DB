CREATE OR REPLACE FUNCTION order_plan()
-- функция добавляет строки в таблицу ПЛАН_МАРШРУТ
AS $BODY$

    DECLARE
        id_ingredient integer[];    -- ИД_ИГРЕДИЕНТА
        mass float;                 -- масса ингредиента
        id_akv integer;             --
        finish boolean;             --
        end_date date;              -- дата завершения пути и сбора
        having_mass float;          -- масса ингредиента, которая уже есть
        end_persent float;          --

    BEGIN
        -- узнать, какие ингредиенты нужны

        -- узнать, какие существа их содержат
        -- узнать, ближайшие популяции с ними



    END;

$BODY$ LANGUAGE plpgsql;


        IF (NEW.НОМЕР_В_ОЧЕРЕДИ <> 1) THEN RETURN NEW;
        END IF;
        FOR id_ingr, mass IN SELECT ИД_ИНГРЕДИЕНТА, МАССА FROM СОСТАВ WHERE ИД_ЛЕКАРСТВА = NEW.ИД_ЛЕКАРСТВА
        LOOP
        SELECT ИД_АКВАТОРИИ  INTO id_akv  FROM ИНГРЕДИЕНТ WHERE ИД_ИНГРЕДИЕНТА = id_ingr;
            FOR having_mass IN SELECT МАССА  FROM НАЛИЧИЕ_ИНГРЕДИЕНТОВ WHERE (ИД_ИНГРЕДИЕНТА = id_ingr) AND (ГОДЕН_ДО > NOW())
            LOOP
            mass := mass - having_mass;
            END LOOP;

        -- тут надо придумать что-то поумнее

        IF (mass > 0) THEN
            finish := FALSE;
            end_date := NOW() + ROUND(mass/10);
            ELSE finish := TRUE; end_date := NOW();
        END IF;
        INSERT INTO ПЛАН_МАРШРУТ VALUES (NEW.ИД_ЗАКАЗА, id_ingr, id_akv, end_date, finish);
        END LOOP;

            end_persent := (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА) AND (СОБРАНО = TRUE)) /
            (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА));
            SELECT MAX(ДАТА_ЗАВЕРШЕНИЯ)  INTO end_date  FROM ПЛАН_МАРШРУТ WHERE ИД_ЗАКАЗА = NEW.ИД_ЗАКАЗА;

            INSERT INTO "СТАТУС_ЗАКАЗА" VALUES (NEW.ИД_ЗАКАЗА, end_persent, end_date);

            RETURN NEW;


CREATE TRIGGER planning
AFTER  INSERT ON "ЗАКАЗ"
FOR EACH ROW
EXECUTE PROCEDURE order_plan();


CREATE OR REPLACE FUNCTION update_plan() RETURNS trigger
AS $$
DECLARE
id_ingr integer[];
mass float[];
id_order integer;
end_persent float;
end_date date;
op varchar(3);
BEGIN
IF (TG_OP = 'INSERT') THEN
	 op = 'NEW';
ELSIF (TG_OP = 'DELETE') THEN
	 op = 'OLD';
END IF;

	EXECUTE 'UPDATE ПЛАН_МАРШРУТ SET ДАТА_ЗАВЕРШЕНИЯ  = ДАТА_ЗАВЕРШЕНИЯ - ROUND(' || op || ' .МАССА/10) WHERE ИД_ИНГРЕДИЕНТА == '|| op || '.ИД_ИНГРЕДИЕНТА';

	FOR id_order IN EXECUTE 'SELECT ИД_ЗАКАЗА  FROM ПЛАН_МАРШРУТ WHERE ИД_ИНГРЕДИЕНТА == ' || op || '.ИД_ИНГРЕДИЕНТА'
	LOOP
	end_persent := (SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = id_order) AND (СОБРАНО = TRUE)) /
	(SELECT COUNT(ИД_ЗАКАЗА) FROM ПЛАН_МАРШРУТ WHERE (ИД_ЗАКАЗА = id_order));
	SELECT MAX(ДАТА_ЗАВЕРШЕНИЯ)  INTO end_date  FROM ПЛАН_МАРШРУТ WHERE ИД_ЗАКАЗА = id_order;

	UPDATE СТАТУС_ЗАКАЗА SET ВЫПОЛНЕНИЕ = end_persent, ДАТА_ЗАВЕРШЕНИЯ = end_date WHERE ИД_ЗАКАЗА = id_order;
	END LOOP;
	EXECUTE 'RETURN ' || op;

END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER planning
AFTER  INSERT OR DELETE ON "НАЛИЧИЕ_ИНГРЕДИЕНТОВ"
FOR EACH ROW
EXECUTE PROCEDURE update_plan();

CREATE OR REPLACE FUNCTION update_orders() RETURNS trigger
AS $$
DECLARE
val integer;
BEGIN
SELECT MAX(НОМЕР_В_ОЧЕРЕДИ) INTO val FROM ЗАКАЗ;
IF val IS NOT NULL  THEN
NEW.НОМЕР_В_ОЧЕРЕДИ = val + 1;
ELSIF TRUE THEN NEW.НОМЕР_В_ОЧЕРЕДИ = 1;
END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER orders
BEFORE INSERT ON "ЗАКАЗ"
FOR EACH ROW
EXECUTE PROCEDURE update_orders();
